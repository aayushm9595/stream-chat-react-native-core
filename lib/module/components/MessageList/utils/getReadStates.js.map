{"version":3,"sources":["getReadStates.ts"],"names":["getReadStates","messages","read","readData","reduce","acc","cur","id","filteredMessagesReversed","filter","msg","updated_at","reverse","readState","last_read","userLastReadMsgId","find","user","Object","values"],"mappings":";;;;;;;;;AAAA;;AAqBO,IAAMA,aAAa,GAAG,SAAhBA,aAAgB,CAS3BC,QAT2B,EAU3BC,IAV2B,EAWxB;AACH,MAAMC,QAAQ,GAAGF,QAAQ,CAACG,MAAT,CAAgB,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC7C,QAAI,CAAC,kCAAgBA,GAAhB,CAAD,IAAyBA,GAAG,CAACC,EAAjC,EAAqC;AACnCF,MAAAA,GAAG,CAACC,GAAG,CAACC,EAAL,CAAH,GAAc,EAAd;AACD;;AACD,WAAOF,GAAP;AACD,GALgB,EAKd,EALc,CAAjB;AAOA,MAAMG,wBAAwB,GAAGP,QAAQ,CACtCQ,MAD8B,CACvB,UAACC,GAAD;AAAA,WAAS,CAAC,kCAAgBA,GAAhB,CAAD,IAAyBA,GAAG,CAACC,UAAtC;AAAA,GADuB,EAE9BC,OAF8B,EAAjC;;AAQA,MAAIV,IAAJ,EAAU;AAAA,+BAIGW,SAJH;AAAA;;AAQN,UAAI,CAACA,SAAS,CAACC,SAAf,EAA0B;AACxB;AACD;;AASD,UAAMC,iBAAiB,4BAAGP,wBAAwB,CAACQ,IAAzB,CACxB,UAACN,GAAD;AAAA,eAASA,GAAG,CAACC,UAAJ,GAAiBE,SAAS,CAACC,SAApC;AAAA,OADwB,CAAH,qBAAG,sBAEvBP,EAFH;;AAQA,UAAIQ,iBAAJ,EAAuB;AACrBZ,QAAAA,QAAQ,CAACY,iBAAD,CAAR,iDACKZ,QAAQ,CAACY,iBAAD,CADb,IAEEF,SAAS,CAACI,IAFZ;AAID;AAhCK;;AAIR,sCAAwBC,MAAM,CAACC,MAAP,CAAcjB,IAAd,CAAxB,oCAA6C;AAAxC,UAAMW,SAAS,qBAAf;;AAAwC,uBAAlCA,SAAkC;;AAAA,+BAKzC;AAwBH;AACF;;AAED,SAAOV,QAAP;AACD,CAhEM","sourcesContent":["import {\n  InsertDatesResponse,\n  isDateSeparator,\n  Message,\n} from '../utils/insertDates';\n\nimport type { ImmutableDate } from 'seamless-immutable';\nimport type { UserResponse } from 'stream-chat';\n\nimport type { ChannelContextValue } from '../../../contexts/channelContext/ChannelContext';\nimport type {\n  DefaultAttachmentType,\n  DefaultChannelType,\n  DefaultCommandType,\n  DefaultEventType,\n  DefaultMessageType,\n  DefaultReactionType,\n  DefaultUserType,\n  UnknownType,\n} from '../../../types/types';\n\nexport const getReadStates = <\n  At extends UnknownType = DefaultAttachmentType,\n  Ch extends UnknownType = DefaultChannelType,\n  Co extends string = DefaultCommandType,\n  Ev extends UnknownType = DefaultEventType,\n  Me extends UnknownType = DefaultMessageType,\n  Re extends UnknownType = DefaultReactionType,\n  Us extends UnknownType = DefaultUserType\n>(\n  messages: InsertDatesResponse<At, Ch, Co, Ev, Me, Re, Us>,\n  read?: ChannelContextValue<At, Ch, Co, Ev, Me, Re, Us>['read'],\n) => {\n  const readData = messages.reduce((acc, cur) => {\n    if (!isDateSeparator(cur) && cur.id) {\n      acc[cur.id] = [];\n    }\n    return acc;\n  }, {} as { [key: string]: UserResponse<Us>[] });\n\n  const filteredMessagesReversed = messages\n    .filter((msg) => !isDateSeparator(msg) && msg.updated_at)\n    .reverse() as Array<\n    Message<At, Ch, Co, Ev, Me, Re, Us> & {\n      updated_at: string | ImmutableDate;\n    }\n  >;\n\n  if (read) {\n    /**\n     * Channel read state is stored by user\n     */\n    for (const readState of Object.values(read)) {\n      /**\n       * If no last read continue\n       */\n      if (!readState.last_read) {\n        continue;\n      }\n\n      /**\n       * Array is in reverse order so newest message is at 0,\n       * we find the index of the first message that is older\n       * than the last read and then set last read to that, or\n       * if there are no newer messages, the first message is\n       * last read message.\n       */\n      const userLastReadMsgId = filteredMessagesReversed.find(\n        (msg) => msg.updated_at < readState.last_read,\n      )?.id;\n\n      /**\n       * If there there is a last read message add the user\n       * to the array of last reads for that message\n       */\n      if (userLastReadMsgId) {\n        readData[userLastReadMsgId] = [\n          ...readData[userLastReadMsgId],\n          readState.user as UserResponse<Us>,\n        ];\n      }\n    }\n  }\n\n  return readData;\n};\n"]}